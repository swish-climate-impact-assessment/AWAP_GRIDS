
setwd('~/data/AWAP_GRIDS')
if(!require(maptools))
  install.packages('maptools',repos='http://cran.csiro.au'); require(maptools)
if(!require(uncompress))
  install.packages('uncompress',repos='http://cran.csiro.au'); require(uncompress)
source('./run/connect2postgres.r')
delphe <- connect2postgres(hostip='115.146.94.209',user='gislibrary',db='pgisdb')
# uncomment in run file so that can be sourced?
source('./run/load2postgres.r')
source('~/tools/disentangle/src/df2ddi.r')

vars<-c('variable,measure,timestep
rainfall,totals,daily
temperature,maxave,daily
temperature,minave,daily
vprp,vprph09,daily
vprp,vprph15,daily
solar,solarave,daily
ndvi,ndviave,month
')
vars<-read.csv(textConnection(vars))

# newnode get_data
get_data_range<-function(variable,measure,timestep,startdate,enddate){
  if (timestep == "day"){
    thisdate<-startdate
    while (thisdate<=enddate){
      get_data(variable,measure,timestep,format(as.POSIXct(thisdate),"%Y%m%d"),format(as.POSIXct(thisdate),"%Y%m%d"))
      thisdate<-thisdate+as.double(as.difftime(1,units="days"),units="secs")
    }
  } else if (timestep == "month"){
    # Make sure that we go from begin of the month
    startdate <- as.POSIXlt(startdate)
    startdate$mday <- 1
    # Find the first and last day of each month overlapping our range
    data.period.start <- seq(as.Date(startdate), as.Date(enddate), by = 'month')
    data.period.end <- as.Date(sapply(data.period.start, FUN=function(x){as.character(seq(x, x + 40, by = 'month')[2] - 1)}))
    # Download them
    for (i in 1:length(data.period.start)){
      get_data(variable,measure,timestep,format(as.POSIXct(data.period.start[i]),"%Y%m%d"),format(as.POSIXct(data.period.end[i]),"%Y%m%d"))
    }
   
} else {
    stop("Unsupported timestep, only 'day' and 'month' are currently supported")
  }
}

#Modified from maptools package
#Reads only the specified number of data items, ignoring BOM's wierd footer
 read.asciigrid2<-function (fname, as.image = FALSE, plot.image = FALSE, colname = fname, proj4string = CRS(as.character(NA))) {
  t = file(fname, "r")
  l5 = readLines(t, n = 6)
  l5s = strsplit(l5, "\\s+", perl = T)
  xllcenter = yllcenter = xllcorner = yllcorner = as.numeric(NA)
  for (i in 1:6) {
     fieldname = casefold(l5s[[i]][1])
     if (length(grep("ncols", fieldname))) 
         ncols = as.numeric(l5s[[i]][2])
     if (length(grep("nrows", fieldname))) 
         nrows = as.numeric(l5s[[i]][2])
     if (length(grep("xllcorner", fieldname))) 
         xllcorner = as.numeric(l5s[[i]][2])
     if (length(grep("yllcorner", fieldname))) 
         yllcorner = as.numeric(l5s[[i]][2])
     if (length(grep("xllcenter", fieldname))) 
         xllcenter = as.numeric(l5s[[i]][2])
     if (length(grep("yllcenter", fieldname))) 
         yllcenter = as.numeric(l5s[[i]][2])
     if (length(grep("cellsize", fieldname))) 
         cellsize = as.numeric(l5s[[i]][2])
     if (length(grep("nodata_value", fieldname))) 
         nodata.value = as.numeric(l5s[[i]][2])
 }
 if (is.na(xllcorner) && !is.na(xllcenter)) 
     xllcorner = xllcenter - 0.5 * cellsize
 else xllcenter = xllcorner + 0.5 * cellsize
 if (is.na(yllcorner) && !is.na(yllcenter)) 
     yllcorner = yllcenter - 0.5 * cellsize
 else yllcenter = yllcorner + 0.5 * cellsize
 map = scan(t, as.numeric(0), quiet = TRUE,nmax=nrows*ncols)
 close(t)
 if (length(as.vector(map)) != nrows * ncols) 
     stop("dimensions of map do not match that of header")
 map[map == nodata.value] = NA
 if (as.image) {
     img = matrix(map, ncols, nrows)[, nrows:1]
     img = list(z = img, x = xllcorner + cellsize * ((1:ncols) - 
         0.5), y = yllcorner + cellsize * ((1:nrows) - 0.5))
     if (plot.image) {
         image(img, asp = 1)
         return(invisible(img))
     }
     else return(img)
 }
 df = data.frame(map)
 names(df) = colname
 grid = GridTopology(c(xllcenter, yllcenter), rep(cellsize, 
     2), c(ncols, nrows))
 SpatialGridDataFrame(grid, data = df, proj4string = proj4string)
 }

# filename must be in format generated by get_data: variable_{startdate}{enddate}
 grid2csv<-function(filename){
        variable<-strsplit(filename,"_")[[1]][1]
        year<-as.numeric(substr(strsplit(filename,"_")[[1]][2],1,4))
        month<-as.numeric(substr(strsplit(filename,"_")[[1]][2],5,6))
        day<-as.numeric(substr(strsplit(filename,"_")[[1]][2],7,8))
        csv_filename<-sub("grid","csv",filename)
        d<-read.asciigrid2(filename)
        #image(d)
        e<-as.data.frame(d)
        names(e)<-c(variable,"long","lat")
        e$year<-year
        e$month<-month
        e$day<-day
        write.csv(e,csv_filename,row.names=FALSE,na="")
 }
