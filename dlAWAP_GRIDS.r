# Function to download the Australian Water Availability Grids http://www.bom.gov.au/jsp/awap/
# Joseph Guillaume
# January 2009
# modified by Ivan Hanigan
# Feb 2012

# newnode TOOLS
if(!require(maptools)) install.packages('maptools');require(maptools)
if(!require(uncompress)) install.packages('uncompress');require(uncompress)

# newnode variable names 
# urls can be like
	# rain                http://www.bom.gov.au/web03/ncc/www/awap/   rainfall/totals/daily/    grid/0.05/history/nat/2010120120101201.grid.Z
	# tmax                http://www.bom.gov.au/web03/ncc/www/awap/   temperature/maxave/daily/ grid/0.05/history/nat/2012020620120206.grid.Z
	# tmin                http://www.bom.gov.au/web03/ncc/www/awap/   temperature/minave/daily/ grid/0.05/history/nat/2012020620120206.grid.Z
	# vapour pressure 9am http://www.bom.gov.au/web03/ncc/www/awap/   vprp/vprph09/daily/       grid/0.05/history/nat/2012020620120206.grid.Z
	# vapour pressure 3pm http://www.bom.gov.au/web03/ncc/www/awap/   vprp/vprph15/daily/       grid/0.05/history/nat/2012020620120206.grid.Z
	# solar               http://www.bom.gov.au/web03/ncc/www/awap/   solar/solarave/daily/     grid/0.05/history/nat/2012020720120207.grid.Z
	# NDVI                http://reg.bom.gov.au/web03/ncc/www/awap/   ndvi/ndviave/month/       grid/history/nat/2012010120120131.grid.Z
vars<-"variable,measure,timestep
rainfall,totals,daily
temperature,maxave,daily
temperature,minave,daily
vprp,vprph09,daily
vprp,vprph15,daily
solar,solarave,daily
ndvi,ndviave,month
"
vars<-read.csv(textConnection(vars))

# newnode get_data
get_data<-function(variable,measure,timestep,startdate,enddate){
url="http://www.bom.gov.au/web03/ncc/www/awap/{variable}/{measure}/{timestep}/grid/0.05/history/nat/{startdate}{enddate}.grid.Z" 
url=gsub("{variable}",variable,url,fixed=TRUE)
url=gsub("{measure}",measure,url,fixed=TRUE)
url=gsub("{timestep}",timestep,url,fixed=TRUE)
url=gsub("{startdate}",startdate,url,fixed=TRUE)
url=gsub("{enddate}",enddate,url,fixed=TRUE)
download.file(url,sprintf("%s_%s%s.grid.Z",measure,startdate,enddate),mode="wb")
}

# newnode get_data_range
get_data_range<-function(variable,measure,timestep,startdate,enddate){
	thisdate<-startdate
	while (thisdate<=enddate){
		get_data(variable,measure,timestep,format(as.POSIXct(thisdate),"%Y%m%d"),format(as.POSIXct(thisdate),"%Y%m%d"))
		thisdate<-thisdate+as.double(as.difftime(1,units="days"),units="secs")
	}
}

# newnode read.asciigrid2
#Modified from maptools package
#Reads only the specified number of data items, ignoring BOM's wierd footer
read.asciigrid2<-function (fname, as.image = FALSE, plot.image = FALSE, colname = fname, proj4string = CRS(as.character(NA))) {
    t = file(fname, "r")
    l5 = readLines(t, n = 6)
    l5s = strsplit(l5, "\\s+", perl = T)
    xllcenter = yllcenter = xllcorner = yllcorner = as.numeric(NA)
    for (i in 1:6) {
        fieldname = casefold(l5s[[i]][1])
        if (length(grep("ncols", fieldname))) 
            ncols = as.numeric(l5s[[i]][2])
        if (length(grep("nrows", fieldname))) 
            nrows = as.numeric(l5s[[i]][2])
        if (length(grep("xllcorner", fieldname))) 
            xllcorner = as.numeric(l5s[[i]][2])
        if (length(grep("yllcorner", fieldname))) 
            yllcorner = as.numeric(l5s[[i]][2])
        if (length(grep("xllcenter", fieldname))) 
            xllcenter = as.numeric(l5s[[i]][2])
        if (length(grep("yllcenter", fieldname))) 
            yllcenter = as.numeric(l5s[[i]][2])
        if (length(grep("cellsize", fieldname))) 
            cellsize = as.numeric(l5s[[i]][2])
        if (length(grep("nodata_value", fieldname))) 
            nodata.value = as.numeric(l5s[[i]][2])
    }
    if (is.na(xllcorner) && !is.na(xllcenter)) 
        xllcorner = xllcenter - 0.5 * cellsize
    else xllcenter = xllcorner + 0.5 * cellsize
    if (is.na(yllcorner) && !is.na(yllcenter)) 
        yllcorner = yllcenter - 0.5 * cellsize
    else yllcenter = yllcorner + 0.5 * cellsize
    map = scan(t, as.numeric(0), quiet = TRUE,nmax=nrows*ncols)
    close(t)
    if (length(as.vector(map)) != nrows * ncols) 
        stop("dimensions of map do not match that of header")
    map[map == nodata.value] = NA
    if (as.image) {
        img = matrix(map, ncols, nrows)[, nrows:1]
        img = list(z = img, x = xllcorner + cellsize * ((1:ncols) - 
            0.5), y = yllcorner + cellsize * ((1:nrows) - 0.5))
        if (plot.image) {
            image(img, asp = 1)
            return(invisible(img))
        }
        else return(img)
    }
    df = data.frame(map)
    names(df) = colname
    grid = GridTopology(c(xllcenter, yllcenter), rep(cellsize, 
        2), c(ncols, nrows))
    SpatialGridDataFrame(grid, data = df, proj4string = proj4string)
}

# newnode grid2csv
# filename must be in format generated by get_data: variable_{startdate}{enddate}
grid2csv<-function(filename){
	variable<-strsplit(filename,"_")[[1]][1]
	year<-as.numeric(substr(strsplit(filename,"_")[[1]][2],1,4))
	month<-as.numeric(substr(strsplit(filename,"_")[[1]][2],5,6))
	day<-as.numeric(substr(strsplit(filename,"_")[[1]][2],7,8))
	csv_filename<-sub("grid","csv",filename)
	d<-read.asciigrid2(filename)
	#image(d)
	e<-as.data.frame(d)
	names(e)<-c(variable,"long","lat")
	e$year<-year
	e$month<-month
	e$day<-day
	write.csv(e,csv_filename,row.names=FALSE,na="")
}


# newnode LOAD
      
# tmax
i <- 2
vars[i,]
get_data_range(variable=vars[i,1],measure =vars[i,2],timestep=vars[i,3],startdate=as.POSIXct("2010-12-30"), enddate=as.POSIXct("2010-12-31"))
# vp
i <- 4
vars[i,]
get_data_range(variable=vars[i,1],measure =vars[i,2],timestep=vars[i,3],startdate=as.POSIXct("2010-12-30"), enddate=as.POSIXct("2010-12-31"))

# newnode uncompress
# test with one
files <- dir(pattern='.grid.Z')
files
for (f in files) {
 print(f)
 handle <- file(f, "rb")
 data <- readBin(handle, "raw", 99999999)
 close(handle)
 uncomp_data <- uncompress(data)
 handle <- file(gsub('.Z','',f), "wb")
 writeBin(uncomp_data, handle)
 close(handle)
 # newnode convert to long csvfor (f in dir(pattern=".grid$")) {
 grid2csv(gsub('.Z','',f))
 }

# newnode CHECK 
# newnode check grid
print(f)
# to select a differnt one
f <- gsub('.Z','',files[3])

d <- read.asciigrid2(f)
str(d)
# compare with http://www.bom.gov.au/jsp/awap/vprp/archive.jsp?colour=colour&map=vprph15&year=2010&month=12&day=30&period=daily&area=nat
# far out that colour scheme is dodgy!
image(d, col = rainbow(19))

# newnode check csv
read.table(sub("grid","csv",f), nrows = 10, sep=',', header=T)

# newnode DO
# now I want to get a time series for a pixel based on the name of a town or city 
# I think I'll load the CSV to PostGIS for spatial query
# also want to check the error between the station observation and the pixel values.
